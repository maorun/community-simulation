use serde::{Deserialize, Serialize};
use std::fmt;

/// Unique identifier for assets in the simulation.
pub type AssetId = usize;

/// Types of assets that can be owned in the simulation.
///
/// Different asset types have different behaviors regarding
/// value appreciation, depreciation, and income generation.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize, Hash)]
pub enum AssetType {
    /// Real estate property that appreciates over time.
    /// Generates rental income and increases in value.
    Property,
    /// Production equipment that depreciates over time.
    /// Enhances production capacity but loses value through wear and tear.
    Equipment,
    /// Financial investments (stocks, bonds) with variable returns.
    /// Can appreciate or depreciate based on market conditions.
    Stocks,
}

impl AssetType {
    /// Returns all asset type variants.
    pub fn all_variants() -> [AssetType; 3] {
        [AssetType::Property, AssetType::Equipment, AssetType::Stocks]
    }

    /// Returns a descriptive string for this asset type.
    pub fn description(&self) -> &str {
        match self {
            AssetType::Property => "Real estate property (appreciates, generates rental income)",
            AssetType::Equipment => "Production equipment (depreciates over time)",
            AssetType::Stocks => "Financial investments (variable returns)",
        }
    }
}

impl fmt::Display for AssetType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            AssetType::Property => write!(f, "Property"),
            AssetType::Equipment => write!(f, "Equipment"),
            AssetType::Stocks => write!(f, "Stocks"),
        }
    }
}

/// Represents a long-term asset owned by a person in the simulation.
///
/// Assets represent wealth storage mechanisms that can appreciate or depreciate
/// over time, generating income or incurring costs. They enable modeling of
/// wealth inequality beyond just liquid money.
///
/// # Value Dynamics
///
/// Each asset type follows different value dynamics:
/// - **Property**: Appreciates at a steady rate, generates rental income
/// - **Equipment**: Depreciates due to wear and tear
/// - **Stocks**: Variable returns based on market volatility
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Asset {
    /// Unique identifier for this asset.
    pub id: AssetId,
    /// Type of this asset (Property, Equipment, or Stocks).
    pub asset_type: AssetType,
    /// Original purchase price of this asset.
    pub purchase_price: f64,
    /// Current market value of this asset.
    pub current_value: f64,
    /// Simulation step when this asset was acquired.
    pub acquired_at_step: usize,
    /// ID of the person who owns this asset.
    pub owner_id: usize,
    /// Total income generated by this asset (cumulative).
    /// For Property: rental income; For Equipment: 0; For Stocks: dividends.
    pub total_income_generated: f64,
}

impl Asset {
    /// Creates a new asset.
    ///
    /// # Arguments
    /// * `id` - Unique identifier for this asset
    /// * `asset_type` - Type of asset (Property, Equipment, or Stocks)
    /// * `purchase_price` - Initial purchase price
    /// * `owner_id` - ID of the person who owns this asset
    /// * `acquired_at_step` - Simulation step when acquired
    ///
    /// # Returns
    /// A new Asset instance with current_value equal to purchase_price
    pub fn new(
        id: AssetId,
        asset_type: AssetType,
        purchase_price: f64,
        owner_id: usize,
        acquired_at_step: usize,
    ) -> Self {
        Asset {
            id,
            asset_type,
            purchase_price,
            current_value: purchase_price,
            acquired_at_step,
            owner_id,
            total_income_generated: 0.0,
        }
    }

    /// Updates the asset's value based on one simulation step.
    ///
    /// Different asset types follow different update rules:
    /// - **Property**: Appreciates by appreciation_rate per step, generates rental income
    /// - **Equipment**: Depreciates by depreciation_rate per step
    /// - **Stocks**: Fluctuates based on stock_return_rate with market volatility
    ///
    /// # Arguments
    /// * `appreciation_rate` - Rate of value appreciation per step (e.g., 0.002 = 0.2% per step)
    /// * `depreciation_rate` - Rate of value depreciation per step (e.g., 0.01 = 1% per step)
    /// * `rental_income_rate` - Rate of rental income generation for Property (e.g., 0.001 = 0.1% per step)
    /// * `stock_return_rate` - Expected return rate for Stocks per step (e.g., 0.003 = 0.3% per step)
    /// * `volatility_factor` - Random volatility adjustment factor for Stocks (typically -0.02 to +0.02)
    ///
    /// # Returns
    /// Income generated during this step (rental income or dividends)
    pub fn update_value(
        &mut self,
        appreciation_rate: f64,
        depreciation_rate: f64,
        rental_income_rate: f64,
        stock_return_rate: f64,
        volatility_factor: f64,
    ) -> f64 {
        let mut income = 0.0;

        match self.asset_type {
            AssetType::Property => {
                // Property appreciates steadily
                self.current_value *= 1.0 + appreciation_rate;
                // Generate rental income as percentage of current value
                income = self.current_value * rental_income_rate;
                self.total_income_generated += income;
            },
            AssetType::Equipment => {
                // Equipment depreciates over time
                self.current_value *= 1.0 - depreciation_rate;
                // Ensure value doesn't go below 10% of purchase price (salvage value)
                let min_value = self.purchase_price * 0.1;
                if self.current_value < min_value {
                    self.current_value = min_value;
                }
            },
            AssetType::Stocks => {
                // Stocks have variable returns with volatility
                let total_return = stock_return_rate + volatility_factor;
                self.current_value *= 1.0 + total_return;
                // Stocks don't pay regular income in this simple model
                // (could add dividends in the future)
            },
        }

        income
    }

    /// Calculates the total return on investment for this asset.
    ///
    /// ROI is calculated as: (current_value + total_income - purchase_price) / purchase_price
    ///
    /// # Returns
    /// ROI as a percentage (e.g., 0.15 = 15% return)
    pub fn calculate_roi(&self) -> f64 {
        if self.purchase_price == 0.0 {
            return 0.0;
        }
        (self.current_value + self.total_income_generated - self.purchase_price)
            / self.purchase_price
    }

    /// Returns the age of this asset in simulation steps.
    ///
    /// # Arguments
    /// * `current_step` - Current simulation step
    ///
    /// # Returns
    /// Number of steps since acquisition
    pub fn age(&self, current_step: usize) -> usize {
        current_step.saturating_sub(self.acquired_at_step)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_asset_creation() {
        let asset = Asset::new(1, AssetType::Property, 100.0, 42, 0);
        assert_eq!(asset.id, 1);
        assert_eq!(asset.asset_type, AssetType::Property);
        assert_eq!(asset.purchase_price, 100.0);
        assert_eq!(asset.current_value, 100.0);
        assert_eq!(asset.owner_id, 42);
        assert_eq!(asset.acquired_at_step, 0);
        assert_eq!(asset.total_income_generated, 0.0);
    }

    #[test]
    fn test_property_appreciation() {
        let mut asset = Asset::new(1, AssetType::Property, 100.0, 42, 0);
        // Appreciation rate of 0.01 (1% per step)
        let income = asset.update_value(0.01, 0.0, 0.002, 0.0, 0.0);

        // Value should increase by 1%
        assert!((asset.current_value - 101.0).abs() < 0.001);
        // Rental income should be 0.2% of new value (101.0 * 0.002)
        assert!((income - 0.202).abs() < 0.001);
        assert!((asset.total_income_generated - 0.202).abs() < 0.001);
    }

    #[test]
    fn test_equipment_depreciation() {
        let mut asset = Asset::new(2, AssetType::Equipment, 100.0, 42, 0);
        // Depreciation rate of 0.1 (10% per step)
        let income = asset.update_value(0.0, 0.1, 0.0, 0.0, 0.0);

        // Value should decrease by 10%
        assert!((asset.current_value - 90.0).abs() < 0.001);
        // Equipment doesn't generate income
        assert_eq!(income, 0.0);
    }

    #[test]
    fn test_equipment_salvage_value() {
        let mut asset = Asset::new(2, AssetType::Equipment, 100.0, 42, 0);
        // Depreciate heavily (50% per step) to test salvage value floor
        for _ in 0..10 {
            asset.update_value(0.0, 0.5, 0.0, 0.0, 0.0);
        }

        // Value should not go below 10% of purchase price
        assert!(asset.current_value >= 10.0);
    }

    #[test]
    fn test_stocks_variable_returns() {
        let mut asset = Asset::new(3, AssetType::Stocks, 100.0, 42, 0);
        // Stock return of 0.05 (5%) with positive volatility of 0.02 (2%)
        let income = asset.update_value(0.0, 0.0, 0.0, 0.05, 0.02);

        // Total return should be 7% (5% + 2%)
        assert!((asset.current_value - 107.0).abs() < 0.001);
        // Stocks don't generate income in this model
        assert_eq!(income, 0.0);
    }

    #[test]
    fn test_calculate_roi() {
        let mut asset = Asset::new(1, AssetType::Property, 100.0, 42, 0);
        asset.current_value = 120.0;
        asset.total_income_generated = 5.0;

        // ROI = (120 + 5 - 100) / 100 = 0.25 (25%)
        let roi = asset.calculate_roi();
        assert!((roi - 0.25).abs() < 0.001);
    }

    #[test]
    fn test_asset_age() {
        let asset = Asset::new(1, AssetType::Property, 100.0, 42, 10);
        assert_eq!(asset.age(10), 0);
        assert_eq!(asset.age(20), 10);
        assert_eq!(asset.age(110), 100);
    }

    #[test]
    fn test_all_asset_types() {
        let types = AssetType::all_variants();
        assert_eq!(types.len(), 3);
        assert!(types.contains(&AssetType::Property));
        assert!(types.contains(&AssetType::Equipment));
        assert!(types.contains(&AssetType::Stocks));
    }
}
